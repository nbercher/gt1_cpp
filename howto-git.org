* Howto Git & Github.com                                           :noexport:
** Table of contents                                              :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#configuration-de-git-et-du-git-workflow-jeu-snake][Configuration de Git et du "Git workflow" (jeu Snake)]]
  - [[#hello-git][Hello Git!]]
  - [[#vue-densemble][Vue d'ensemble]]
  - [[#détail-des-étapes-à-réaliser][Détail des étapes à réaliser]]
  - [[#conclusion][Conclusion]]
- [[#git-basics][Git basics]]
  - [[#quest-ce-que-git][Qu'est-ce que Git?]]
  - [[#créer-un-dépôt][Créer un dépôt]]
  - [[#ajouter-commiter][Ajouter, commiter]]
  - [[#voir-les-modifications][Voir les modifications]]
  - [[#voir-lhistoire-du-dépôt-dun-fichier-et-survol-des-branches][Voir l'histoire du dépôt, d'un fichier (et survol des branches)]]
  - [[#trois-univers-dans-un-dépôt-git-working-tree-git-et-index][Trois "univers" dans un dépôt Git: working tree, .git/ et index]]
  - [[#dépôts-nus-bare-clones][Dépôts nus (bare clones)]]
  - [[#dépôt-nu-pousser-push-et-tirer-pull][Dépôt nu: Pousser (push) et tirer (pull)]]
  - [[#à-savoir-pull--fetch--merge][(À savoir) Pull = fetch + merge]]
- [[#le-git-workflow-au-quotidien][Le Git workflow au quotidien]]
#+END_QUOTE

* Configuration de Git et du "Git workflow" (jeu Snake)          :TODOélèves:
** Hello Git!

Avant d'utiliser Git, on se présente:

 1. Configurer son prénom et son nom:

    #+BEGIN_EXAMPLE
    git config --global user.name "PRÉNOM NOM"
    #+END_EXAMPLE

 2. Configurer son e-mail:

    #+BEGIN_EXAMPLE
    git config --global user.email MON_EMAIL
    #+END_EXAMPLE

** Vue d'ensemble

Exemple pour un binôme n°1 (codename: b01) avec élève1 et élève2

 - On va créer un dépôt par binôme pour le jeu

 - *Votre dépôt n'est crée qu'une seule fois*, ensuite il sera cloné (à volonté)

 - Créer ce dépôt initial ensemble (binôme, trinômes)

** Détail des étapes à réaliser

Choisir qui sera élève1 et qui sera élève2.

*** Étape 1: Init: Initialisation du dépôt sur Github.com

 1. élève1 se connecte sur Github.com

 2. Depuis sa page https://github.com/COMPTE_GITHUB_ÉLÈVE1, élève1 crée le dépôt Git:

    - Cliquer sur "Repositories" (onglet en haut), puis sur le bouton "New" (en vert)

    - Remplir "Repository name" *avec un nom de dépôt de la forme*:
      =gtech1-bXX-snake=

    - Cliquer sur "Add a README file"

    - Cliquer sur "Create repository"

    - Le dépôt est maintenant créé sur github.com

*** Étape 2: Fork: Clonage d'un dépôt du compte Github élève1 dans le compte Github élève2

 - Je suis élève2: je "fork" le dépôt Github.com de élève1 *sur mon Github.com*:

   1. Je me connecte sur Github.com

   2. Je vais visiter la page du compte élève1:
      https://github.com/COMPTE_GITHUB_ÉLÈVE1/gtech1-bXX-snake

   3. Je clique sur "Fork" (en haut à gauche)

      *J'ai maintenant un clone du dépôt de élève1 dans mon compte github.com*

 - Au final: *Chacun doit avoir les 1 dépôt =gtech1-bXX-snake= son compte Github*

*** Étape 3: Créer sa clé SSH

 - Note: Si vous avez encore votre clé SSH du projet#2, vous pouvez la réutiliser

 - Créez votre *paire de clés SSH* au format ED25519:
   (Une clé SSH permet de ne plus avoir à saisir son mot de passe à tout bout de champ!)

   =mkdir -p ~/.ssh && cd ~/.ssh && ssh-keygen -t ed25519 -C MON_EMAIL=

   Note: Vous demande une "passphrase", *il est préférable de la laisser vide*
   (appuyer sur ENTRÉE sans rien répondre à la question)

   IMPORTANT:
   - La commande ci-dessus créé une paire de fichiers (dans le dossier courant, ici ~/.ssh):
     - clé publique: =~/.ssh/id_ed25519.pub=  Vous pouvez la diffuser
     - clé privée:   =~/.ssh/id_ed25519=      *NE JAMAIS PARTAGER VOTRE CLÉ PRIVÉE!!!*
   - [Info: Vous pouvez avoir autant de clés SSH que nécessaire pour divers usages]

 - Importer votre clé ***publique*** =~/.ssh/id_ed25519.pub= sur Github.com

   - Sur Github.com: "settings" / "SSH & GPG keys", cliquer sur "New SSH key" (en vert)

   - Copier-coller le contenu de la clé publique:
     - Pour la copier: =cat ~/.ssh/id_ed25519.pub= puis copier toute la ligne avec Ctrl+Shift+C
     - Pour la coller: dans Github.com, donner par exemple le nom =gtech1= à votre clé

   - Cf. la doc sur le site: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account

*** Étape 4: Clone: Cloner le dépôt Github en local sur sa machine (mode SSH)

 - Pour élève1 et élève2: je clone simplement le dépôt github.com sur ma machine @G.Tech1:
   =mkdir -p ~/proj7/ && cd ~/proj7/=

   Je clone mon dépôt Github:
   =git clone git@github.com:MON_COMPTE_GITHUB/gtech1-bXX-snake.git snake=

 - Notes/Rappels:
   - Dans les grandes lignes, la commande =git clone URL= fait en interne:
     - =git init= : féer un dépôt local
     - =git pull URL main= : récupérer l'histoire distante

   - La commande =git clone URL DOSSIER= *créé le clone dans un nouveau sous DOSSIER*.

*** Étape 5: Push, pull: *Test 1* - Git pull & push sur mes dépôts à moi

Pour tout le monde: depuis ma machine @G.Tech1:

 - *Je teste pull et push* entre mon dépôt local et son miroir Github.com:

   =cd ~/proj7/snake/; git pull ; git push=

   *Ces commandes ne doivent pas afficher d'erreurs.*

*** Étape 6: Pull: Syncho croisée read-only =Git ← Github= autre élève (mode HTTPS)

 - Je rajoute un point de synchronisation avec le dépôt github.com du/des autre(s) élève(s):

   - Pour *chacun de mes camarades du binôme* (= 1 pour les binômes, = 2 pour les trinômes):

     =cd ~/proj7/snake/=
     =git remote add ALIAS_AUTRE_ELEVE URL_HTTPS_AUTRE_ELEVE=

     Avec:

     - =ALIAS_AUTRE_ELEVE=: donner un *nom court* en *miniscules* pour le *dépôt Github de votre camarade*
       Il sera utilisé pour faire: =git pull ALIAS_AUTRE_ELEVE main=

     - URL_HTTPS_AUTRE_ELEVE=: du type =https://github.com/COMPTE_AUTRE_ÉLÈVE/gtech1-bXX-snake.git=

*** Étape 7: *Test 2* - Git pull des modifs du dépôt Github de l'autre élève

Pour tout le monde, depuis le PC @G.Tech1:

 - *Je teste pull* entre mon dépôt local et le dépôt Github.com des autres élèves:

   =cd ~/proj7/snake/ ; git pull ALIAS_AUTRE_ELEVE main=

   Notes:
   - Ces commandes (bien que inutiles à ce stade) ne doivent pas afficher d'erreurs.
   - =ALIAS_AUTRE_ELEVE= a été décrit plus haut dans la section
     "Syncho croisée read-only =Git ← Github= autre élève"

*** Mise à jour du Fichier Google "URL dépôts Github"*

Une fois vos dépôts Github.com et Git locaux en place:

Complétez le Fichier Google *"URL dépôts Github"* avec vos 2 URL (1 colonne URL par jeu).

** Conclusion
Si les tests "Test 1" et "Test 2" ont fonctionné, alors vous avez mis
en place ceci et *votre coach vous félicite*:

#+BEGIN_EXAMPLE
           élève1                              élève2
           ======                              ======
         Github.com  ───────       ───────   Github.com
              ↑              ╲   ╱                ↑
            │ │               ╲ ╱               │ │
      pull--│ │--push          ╳          pull--│ │--push
       SSH  │ │  SSH    pull--╱ ╲--pull    SSH  │ │  SSH
            ↓          HTTPS ╱   ╲ HTTPS        ↓
         PC@G.Tech1  <──────       ──────>   PC@G.Tech1
#+END_EXAMPLE

En résumé:
 - J'envoie mon travail vers mon mirroir Github: =git push=
 - Je récupère le travail de mon/mes binôme(s): =git pull ALIAS_AUTRE_ELEVE main=
 - Si j'ai plusieurs machines pour travailler, j'utiliserai =git pull=
   sur toutes mes machines si j'ai fait auparavant un =git push= depuis une autre machine

   Diagrame simplifié:

   =machine1 <- pull,push -> Github.com <- push,pull -> machine2=

* Git basics
** Qu'est-ce que Git?

 - Outil créé par par Linus Torvalds en 2005, créateur de Linux, pour
   continuer à développer Linux

 - Grands principes:

   - Git travaille à l'échelle d'un dossier de départ et se préoccupe uniquement de ses sous-dossiers et
     sous-fichiers

   - Git enregistre les changements des fichiers dans des "commits"

   - Les commits s'enchainent (analogue à une blockchain), ils forment une histoire des fichiers =
     versionnement

   - Git permet de transférer les commits par le réseau et à des utilisateurs de synchoniser leur travail

   - Git sait fusionner (merge) les codes sources édités par plusieurs personnes en même temps

 - Usages de Git:

   1. Versionner le code source: enregistrement des changements importants et à préserver

   2. Synchroniser les dépôts (ex: avec Github.com)

** Créer un dépôt

 - INFO: Nous avons déjà crée notre dépôt via Github.com, mais nous aurions pu le faire en local:
   - Créer un dépôt tout neuf:

     =git init= ou =git init NOM_DOSSIER=  -> Ce dépôt ne contient aucune histoire

** Ajouter, commiter

 - Demander à Git de *suivre un fichier*:

   =git add fichier=  -> Avant cela Git ne se préoccupait pas de ce fichier
                      -> Rajoute le fichier à l'Index pour constituer le futur commit

 - *Sceller les modifications* par un commit (ou "Commiter"):

   =git commit=       -> Tout le contenu de l'Index est rajouté à l'histoire du dépôt

   Une fois un fichier suivi par Git (=git add=), on peut faire directement:

   =git commit fichier= -> Toutes les modifications depuis son dernier commit sont rajoutées
                           à l'histoire du dépôt, cela "saute" l'étape de l'Index

 - Mais alors pourquoi l'Index?  Car on peut y rajouter des modifications de plusieurs
   fichiers et *vérifier son FUTUR commit* (avec =git diff --cached=)

** Voir les modifications

 - Liste des modifications (non-commitées) faites sur le dépôt:

   =git status=     -> Pas super lisible...

   =git status -s=  -> Super lisible, organisé en deux colonnes:

   A  Makefile                    _Légende_:
    M puis4.c                     A pour Added
   MM puis4.h                     M pour Modified
    D puis4.o                     D pour Deleted (il en existe d'autres: U, T, etc.)

   Colonne gauche: modifications qui *sont dans l'Index*
   Colonne droite: modifications qui *ne sont PAS dans l'Index*

   (On me demande de vous rappeler que l'Index EST le FUTUR commit.)

 - Voir les modifications (non-commitées) faites sur les fichiers:

   =git diff=         -> Voir le =diff -Nu fichier1 fichier2= des fichiers par rapport au dernier commit
   =git diff fichier= -> Restreindre le =diff= à un (ou plusieurs) fichier(s)

** Voir l'histoire du dépôt, d'un fichier (et survol des branches)

 - Un dépôt Git est fait de branches, dont celle par défaut =main=

   (Nous n'utiliserons probablement pas les branches...)

   (Néanmoins sachez que c'est très puissant et permet de travailler
   sur plusieurs fonctionnalités d'un projet en parallèle.
   Par ailleurs, passer d'une branche à l'autre dans votre "working
   tree" modifie les fichiers de manière à ce qu'ils correspondent à
   leur état dans la-dite branche, tout en s'assurant de rien casser.)

 - Histoire d'une branche du dépôt = *liste ordonnée de commits*

   A---B---C---D---E = =main=

   =git log=         -> Affiche la liste des commits (de la branche courante)

   =git log fichier= -> Affiche la liste des commits concernant seulement =fichier=

** Trois "univers" dans un dépôt Git: working tree, .git/ et index

   1. *working tree*: "Copie de travail" (ou "Dépôt local") = dossier contenant vos fichiers
      + sous-dossier =.git/=

   2. =.git/= ("dot git"): Sous-dossier contenant tout ce que Git doit savoir sur votre dépôt:
      configuration et *histoire des fichiers*

   3. *Index* (ou "staging" ou "cache"): Ceci est votre futur *commit*
      (il est matérialisé quelque part dans =.git/=)

** Dépôts nus (bare clones)

 - On créé toujours un dépôt avec =git init= (même si c'est Github qui le fait à votre place)

   - Un tel dépôt est un dossier avec un sous-dossier =.git/=

   - Ce dossier =.git/= est (presque) un *dépôt nu* (à la config près)

 - Un dépôt nu n'est pas un espace de travail, mais *un point de synchronisation*

 - Un dépôt hébergé sur Github.com est TOUJOURS un dépôt nu

 - On peut créer un dépôt nu à partir d'un dépôt local:

   =git clone --bare DÉPÔT/ DÉPÔT.git= -> Ceci créé un dossier =DÉPÔT.git/=,
                                          ça ne vous rappelle rien ce =.git/=?

** Dépôt nu: Pousser (push) et tirer (pull)

 - En général, tout dépôt Git local (working tree) à un *clone nu* quelque part
   (autrement, il faudrait certainement en créer un)

 - Envoyer ses modifications vers un dépôt nu:

   =git push DÉPÔT BRANCHE=

 - Recevoir les modifications depuis un dépôt nu:

   =git pull DÉPÔT BRANCHE=

 - Les éléments =DÉPÔT= et =BRANCHE= sont définis dans la config du dépôt (=.git/config=)

 - IMPORTANT: Quand on travaille à plusieurs, on procédera dans l'ordre suivant:
   1. =git pull ...=
   2. =git push ...=

   De manière à récupérer le travail des autres AVANT de n'envoyer le sien.
   Ceci permet d'effectuer une opération de =merge=...

** (À savoir) Pull = fetch + merge

 - L'opération =git pull ...= fait deux choses:

   1. =git fetch ...= -> récupérer les modifications SANS les appliquer à votre histoire

   2. =git merge=     -> appliquer les modifications en les fusionnant dans votre histoire

   On imaginera aisément que =git merge= est très puissant...
* Le Git workflow au quotidien

 1. élève2 se réveille (boit son café)

    - *Premier réflexe*, récupérer le travail de ses binômes *si on lui a demandé* ("pull request"):

      Sur sa machine: =git pull ALIAS_AUTRE_ELEVE main=

 2. élève2 se met au boulot (un autre café?)

    - élève2 modifie son code et il en est content!

    - élève2 *communique avec ses binômes* sur son travail

    - élève1 est enchanté par le travail de élève2 et le récupère au plus vite!

      Sur sa machine: =git pull ALIAS_AUTRE_ELEVE main=

 3. La journée continue et *ce cycle se reproduit aussi souvent que nécessaire*

